MT.Gox 迈得嘎斯，以下简称MT

## 点
最早是美国企业家 杰德 在 2010 年 7 月创办。杰德 想法很简单，当时一个比特币已经可兑换数美元，而且挖矿机正在源源不断地产出新的比特币，他想建立一个交易所可以连接买家和卖家。
但是，很快，这个交易所花光了 杰德 所有的积蓄，于是出售给另一位比特币爱好者，
## 点
也就是图片中的 马克
2011 年，他将 MT.Gox 收购。
马克 将网站的后端软件重写，改进了用户体验，加上他在比特币社区的活跃，越来越多的人在这里交易比特币，最终它变成了最流行的交易平台，承担着全球 70% 的交易。
事实证明，马克 对于技术的精通在网站发展初期十分有效，但是在后期，马克 在商业管理的不足逐渐凸现出来，但 MT 并未因此做出改变。
比特币价格的飞涨给参与进来的人巨大的回报，MT 处理的流水越来越多，通过手续费累积的比特币也越来越多，数量达到了 10 万级别，总价值数千万美元。马克 的身价也水涨船高。
但这些光环却掩盖不了 MT 在业务上的问题，问题主要还是出在产品上，MT 很长一段时间都不使用控制软件来制定专业的开发环境，这意味着两个同事在同一个文件夹下工作，很有可能覆盖掉对方的代码。
他们甚至把许多不经测试的软件推送到用户手机上，要知道他们是做金融服务的，这样做很容易引发问题。
2011 年 6 月，MT 首次遭遇黑客攻击，当时受此影响，MT.Gox 比特币的价格暴跌，从 30 美元跌至 0.01 美元，比特币市场遭遇重创。
## 点
比特币爱好者 杰西 从旧金山赶过来
与好友 罗杰 一起帮 MT 解决问题，他们还没来得及放下行李就去办公室工作。
杰西 和 罗杰 工作了一整周来修复问题，但是直到周末，问题还没解决。杰西和罗杰 准备周末接着干，
## 点
但意外的是，马克 却决定周末放假休息，让两个志愿者大跌眼镜，他们感到十分泄气。
马克 并未真正重视这个问题，等到周一开工，他却花时间在整理信封，把问题丢在一边。
随着 2014年2月份到来，危机终于降临，黑客利用比特币“交易可延展性”，将 MT 中的比特币洗劫一空
2014年2月底，MT举行新闻发布会，会上承认丢失了 85 万个比特币，价值近 4.7 亿美元。
在这 85 万个比特币中，75 万个属于客户，10 万个属于 Mt 自有资产。
## 点













比特币的延展性
什么叫做 延展性，说是延展性，也可以理解为可塑性。举个例子来说《龙门镖局》中的白敬祺为了藏私房钱，将银锭打成了银夜壶，而银夜壶和银锭的价值是相当的，这就是金属“可锻性”的物理表现。
比特币的一个“交易”是一段指令，这段指令告诉整个网络：我作为一些比特币的拥有者，要把他们的所有权转移到目标地址。这样，谁拥有目标地址，我就把钱打给谁了。
这段指令本质上是一个hash字符串，就像这样：
## 点
然后，你对这个字符串提取一个所谓的哈希，可以理解为用摘要的方式获得一个比较短的字符串，像这样的：
## 点
这个东西就是咱们说的交易ID txid
现在我们一步步的来看看这样到底如何完成交易延展性攻击的。
首先我们来看一个交易的原始数据
## 点
在这里可以看到，input 和 out 都存在一个 script 字符串
接下来，我们首先将 输入脚本进行格式化
## 点
这个就是原始的脚本，它主要包含的是，签名和公钥
## 点
输出脚本格式化之后我们可以看到，它存在很多脚本操作符。

在这里，扩展一下，比特币在交易中使用的脚本，比特币使用的脚本与FORTH(一种编译语言)一样，脚本是简单的、基于堆栈的、并且从左向右处理，它特意设计成非图灵完整，没有LOOP语句。
它和逆波兰表达式类似，基于堆栈来执行。

接下来我们来演示下比特币是如何确认一次交易的。
## 点


#######  自己看着点
首先执行的是『输入脚本』。因为脚本是从左向右执行的，
那么先入栈的是『签名』，
随后是『公钥』
接着，执行的是『输出脚本』。从左向右执行，
第一个指令是OP_DUP——复制栈顶元素
OP_HASH160——推出并计算栈顶元素Hash，得到pubkeyhash，并将它放入栈顶
将『输出脚本』中的『公钥哈希』入栈，为了和前面计算得到的哈希区别，称它为pubkeyhash’
OP_EQUALVERIFY——检查栈顶前两元素是否相等，如果相等继续执行，否则中断执行，返回失败
OP_CHECKSIG——使用栈顶前两元素执行签名校验操作，如果相等，返回成功，否则返回失败

当交易发送到比特币网络中后，网络中的各个结点会根据之前生成的签名来验证交易的真实性，这些做法都是很正确很理所当然的，MT就是这么做的，当你提现的时候，它就发出一个交易，然后记录下这个ID。当有人提现出问题要求重发时，他们就用这个ID去比特币网络检查这个ID有没有被确认，如果没有的话就重发。而问题就出现在签名算法中，由于现在大部分使用的签名算法都是基于OpenSSL的ECDSA（椭圆曲线数字签名），这个签名算法的一个问题就是，修改签名的某个字节能够使得签名依然校验成功，这样伪造签名之后交易依然能成功进行。如果单在比特币网络中这似乎没什么大不了的，顶多可以捣捣乱，因为你能使用的输出就那一个，你其中一笔交易使用了输出，第二笔自然就不会成功。但是对于第三方交易系统就不同了

记下来我们看看如何模拟一次攻击。

## 点

#######  自己看着点

大家还会有一个疑问，就是我们伪造的交易请求是在正常交易请求之后发出的，如果正常交易被采纳了，那我们伪造的交易如何能够奏效呢？这里就要说到比特币网络的一个特性，发出一个比特币交易请求后不会立刻返回交易成功与否，在比特币网络中会有一个处理延时，而比特币网络由于自身的特性，所有交易请求是以网状形式随机处理的，两次交易请求并不会以队列形式依次处理。这就给攻击者提供了可乘之机，专业的讲叫做时间条件竞争，通俗的讲就是拼人品。我们伪造的交易和正常的交易都在比特币网络中，如果伪造的交易先被处理，那么攻击成功。


隔离见证，就是把交易中见证脚本，提取出来，放到单独的数据结构里。这样子的话，交易变得安全，并且交易的大小会变小，因为在一笔交易中，见证脚本甚至可以占到75%。这样也在一定程度上实现了比特币的扩容。




为什么需要闪电网络


## 点
首先我们来说一下，现在比特币网络中存在的问题。

## 点
处理能力
在最理想状态下，平均每笔交易225 字节。在1M区块限制下，一般平均10分钟可以打包大约 4400 笔交易。每秒大约7.3笔交易，实际交易平均大小是这个的一倍，那么容量减半，也就是每秒大约 3.6 笔交易。
与当今的金融系统相比，Visa在标准的节假日每秒处理4.5万笔交易，通常的一个营业日则为数亿次交易。支付宝的每秒可以处理10万笔交易。而2017年的双11，支付峰值每秒25.6万笔。，然而比特币现在每秒约能支持7笔交易，同时还会受到区块链大小的限制。

## 点
时间延迟
每一笔交易发起的时候，会出现10分钟的延迟，才会有可能被矿工确认。并且目前的交易量上升之后，你被确认的等待时间和你的手续费成反比，也就是说你的手续费越低，你被处理的顺序就越靠后。

## 点
交易最终性
由于算哈希是随机的，加上网络有延迟，是有同时挖出两个区块的可能，然后不同的矿工根据他们收到的区块不同继续挖，然后还是有可能再出现分叉，但是几率会越来越小。
一般认为一个区块在最长链上后面跟了五个区块，就不可能被分叉了。随着区块数量的增加，再次产生分叉的几率是呈指数下降的。到了6的区块的时候，就已经下降到不太可能分叉的情况

## 点
容量
比特币，区块目前已经到51W多个区块。这么多的区块产生的容量是巨大的,而且以后只增不减

## 点
交易费
中本聪最开始确定bitcoin一共有2100万个，当全部挖掘出来之后，矿工将不再获得奖励，到那个时候，矿工所有的收益都来自交易中的手续费。就目前为止，待确认交易堆积的这么多，也和交易费有关系，如果你想矿工早点确认你的交易，那么你就需要提高你的手续费，否则就没人处理。但是这个引起的来问题，也很明显，我就想买杯咖啡，就需要支付手续费吗？

那么以后大概我们去买咖啡的时候，会遇到这种情况
## 点

你再付完钱后，不能立马走，你需要等待。

## 点

那到时候店规大概会是，顾客付比特币之后需要等至少一个小时才可以喝到咖啡，并且每杯咖啡会高于使用法币购买的，因为需要手续费。

这个时候我们就需要闪电网络了。

## 点

闪电网络 的基础基于 双向微支付通道，这里的微支付也说明，他尽可能的希望单次支付的金额足够小，即使一方违约另一方的损失也非常小，风险可以承受。因此使用时必须注意“微支付”这个前提。多少资金算“微”，显然应该根据业务而定。

## 点

而，我们要说的 RSMC 定义了该双向微支付通道的最基本工作方式

我们来模拟下这个过程是如何的

我们这里有两个好邻居，他们分别是花店老板娘和酒店老板，花店老板娘回去酒店买酒，而酒店老板也会去买花。如果他们每次都是用比特币的结账的话。相互找零和付钱很麻烦。

他们就决定各拿出来100块钱，放在另一个人哪里。

他们会创建一个账本来记录各自的消费记录，以及余额情况。

并且他们为了对方耍赖，每次更新账单的时候都会签字表示这个交易是自己承认的。

之后他们人手一份

并且记录当前的账单的详情，分别为100

花店老板娘区酒店买了瓶酒 花了 10

账单会发生如下更新，并且其中的时间格式也会发生变化。标志着之前的账单废除。

在之后，酒店老板在花店老板这里买了40 的花。

账单再次发生变化，并且时间也会发生变化 这样可以持续无限次

当然，如果某天酒店老板想拿回冻结的钱，他只只需要把账单给三方的人，这个人就会按照账单上的余额把钱发给各自的账户中。

当然，第三方发放余额的时候会有一段时间的缓冲时间，这主要是为了防止有人拿着坏账的情况。

酒点老板，在花费40之后出现了坏点子，他直接拿起了第二份账单去到了第三方。

在缓冲时间之内，花店老板拿出比酒店老板提取现金时间距离现在更近的账单的话，酒店老板不仅不会获得金币，反而会失去所有的金币。

通过构建适当的“举证”证据并结合罚没机制实现的。

为了鼓励双方尽可能久地利用通道进行交易，RSMC对主动终止通道方给予了一定的惩罚：主动提出方其资金到账将比对方晚，因此谁发起谁吃亏。这个设计虽然增加了技术复杂度，但应该说是合理的。



我们来用比特币中的经典人物， Alice 和 Bob 。

在这里，我们假设 Alice 拿出0.5个比特币，Bob也拿出0.5个比特币。

他们首先准备建立一个交易 Funding[分定]。

这个交易的输入是 Alice 的签名和Bob的签名，但是此时我们不签名，更不去广播这个交易。

我们再来看输出，输出为 Alice和Bob的 必须两个人都同意的多重签名。

接下来我们来看看 Alice构建它的第一个交易 C1a，他的输入本来应该是自己的签名以及Bob的签名，但是现在还没有签名。

记下来构建输出，输出有两个，第一个输出是 Alice的另一个把秘钥的 Alice2和Bob的多重签名。第二个输出为 Bob的0.5Btc。

接下来，来看看Alice构建的第二个交易 RD1a，这个交易的输入应该是 Alice2和Bob的签名，但是现在还没有

而它的输出呢是 Alice的0.5 个比特币，但是他和第一个交易不同的是，它的输出存在一个 sequence 1000.这个的作用时说，当前一笔交易确认到了1000个块的时候才会进入区块，才会被确认。 以当前值设为1000来计算的话，要接近一个星期才会被写入块...

这也是为了鼓励双方尽可能久地利用通道进行交易，主动提出方其资金到账将比对方晚，因此谁发起谁吃亏。

我们也为 Bob创建同样的交易。

在这个时候，我们的两笔交易已经创建完成了。我们将Alice 和 Bob的交易，进行交换的签名。

此时由于 Funding 交易并没有进行签名甚至说都没有广播，所以他们现在的交换是绝对安全的，任何一方都无法作恶，任何一方也不会吃亏。

双方都完成了交易之后，都各自对 Funding交易进行签名。此时 Funding 交易就已经是完整的交易了，广播它～

至此一个 RSMC 通道就此建成。






Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。

此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？
RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2的私钥交给Bob，即表示Alice放弃C1a，承认C2a

Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币，这个Bob建立的简易叫做，作恶惩戒交易，就是用来惩戒不守规矩的一方。RD1a引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。反之亦然。

正常情况下，Alice只要不在区块链上发布C1a，虽然Bob拥有输入解锁脚本完全就绪的BR1a，因为其父交易C1a并未发布，Bob也无法发布BR1a。这说明只要一方安分守己，就无需担心惩罚措施。

而交易关闭，咱们前面也说了，除了率先关闭交易的人会收到一些惩罚之外，其他没有任何影响，当然这一切都是没有人作弊的情况。








咱们再来看一下什么事 HTLC，HTLC简单来说就是为 RSMC提供了一个 有条件的资金支付方式。

具体是如何运作呢，我们还是来使用刚才的例子，花店老板，和酒店老板

在RSMC他们已经通过签名完成了，他们之前的快速交易了。但是，一笔还好，要是每一笔？都需要签名？

在这个便捷的时代，绝对不与许这种行为啊。

所以，花店老板预先准备了一些钱，并且给这个锁加了一个钥匙，交给了第三方，告诉他，如果有人道你这里解开锁，拿钱就让他拿吧。

然后，花店老板去酒店老板哪里消费。消费完成之后，花店老板，直接丢给他一把钥匙。这样就不需要签名了，直接就可以不需要签名了。

而酒店老板只需要，拿着钥匙道第三方哪里，将锁解开。

就可以把钱拿到手了。








咱们再来看一下，HTCL的具体实现，在之前我们 看到了 RSMC的实现。

现在让我们来开始 HTCL的实现。

之前的交易展现方式不太适用现在了，我们调整为这个样子。

在这里，我们在 C2a交易增加一个新的输出，这个输出地址为为一段脚本，类似与这样子的脚本

在这个脚本里，我们可以看到它的流程处理，如下，首先，根据栈顶的元素的hash160和已经存在的hash值进行匹配，如果成功，继续匹配多重签名。否则，就调入下一个流程处理。

这里我们来模拟，Alice在Bob消费了0.1 bitCoin 的整个过程。

首先，Alice在Bob消费了0.1 bitCoin 给予R 之后，Bob 创建 HE1b交易，这里需要传递的输出分别为 Bob的一个签名 和 Alice的一个签名 以及一个 R值。如果传递成功之后，就可以输出一个交易，这个交易 的输出就是 Bob得到1个比特币。当然如果不符合规则的话，就会退回Alice的账户中。当然该操作符合闪电网络的先提出会收到惩罚的原则，我们的Bob需要交易确认1000个块，才可以提取到钱。

创建了这个交易之后，只要Bob 把 C2b D2b Rd2b 以及 He1b HERD1b 这个五个交易都发布出去就可以了，领取到0.6个bitCoin 而 Alice 会得到0.4个比特币，而整个交易通道到此也就关闭了。

那么我们如何，保持通道呢？很简单... 就是BOb离线告诉Alice他拥有适当R，且Alice和Bob都愿意达成新的余额划分，那么就新建一个 0.4 和 0.6 的新版本余额，并且废除旧版本，就可以了。好吧... 那既然如此 HTLC存在的意义在哪儿.... 在之后的 闪电网络，我们会知道为什么的

我们也可以看到 Alice这边也有一个交易，它的输出是 以 Alice获得 0.1bitcoin。但是前提是 LockTime > 3 这就是给予 Bob获得R钥匙的3天时间，如果到了3天时间之后，Bob没有提供相对应的R值的话，Alice 可以构建该交易，并且需要构建另一个交易。Alice把 C2a  RD2a D2a HT1a, HTRD1a 这五个交易来完成交易，倒是Alice和Bob都会获得0.5比特币。当然还是先发起申请的人还是会延迟1000个块确认时间才会入块。








建立新版本余额快照后，就应该作废旧版本。和之前作废旧版本的思路类似，在通道中还包含HTLC合约的情况下，依然靠新增若干作恶惩戒交易的方式作废旧版本。
图中用红色虚线框出的部分就是新增的“作恶惩戒交易”。

假设HT1a交易已经超时，但以C2a为根的全部交易都已通过惩戒交易予以作废。如果此时Alice想作恶，她将C2a、RD2a、HT1a及HTRD1a区块链上公开。由于seq字段的限制，她不能立刻公开交易RD2a和HTRD1a，这样就使得Bob有机会发现Alice企图作恶并能够通过公布BR2a和HTBR1a交易的方式予以惩戒。发出这对交易后，通道中的全部资金将都归Bob所有。

虽然没有用上惩戒交易HBR1a，但该交易并不多余。理由是：如果Alice在区块链上公布了交易C2a但故意不公布交易HT1a，倘若Bob手头没有HBR1a，也不知道秘密R，Bob将无法获得这0.1 BTC。有了惩戒交易HBR1a之后，即使Alice不公布交易HT1a，只要C2a公布，Bob也可以通过HBR1a顺利提取这0.1 BTC。

只提供HBR1a、不提供HTBR1a也是不行的。因为万一Alice选择的是解锁并公布交易HT1a，并且抢在Bob之前消费了C2a的#2输出，Bob拥有的HBR1a交易就无法生效了，而此时虽然HTRD1a交易要等上1000个确认才能公布，Bob也没有任何手段来利用这1000个块的确认时间来阻止Alice提取这0.1 BTC。







闪电网络，简单来说就是中转交易，我们这里还是拿花店老板和酒店老板讲解，但是这个时候多了一个饭店老板

有一天，饭店老板 买酒10 元，临付账的时候，他和酒店老板并没有通道。所以没有办法直接交流。

但是饭店老板和花店老板有一个通道，那么这样子一个简单的网络就产生了。

这个时候饭店老板就私底下对酒店老板说“嘿，老酒，我要给你付笔钱”。

这个时候，老酒就生成了一个随机数，活着你可以理解为随便的一种密码，并且声称对应的一个Hash值，并把他交给饭店老板。

饭店老板，联系花店老板，说，老花，你只要给我一个密码，和我这边匹配了，我给你10.1。

花店老板虽然不知道密码，但是他还是答应了，他找到酒店老板，创建了一个新的交易粉配方案，并说，老酒，你只要给我密码，我就给我10

这个随机数本来就是老酒说的，自然知道就告诉老花。老花告诉老饭，老饭验证完成之后发现还真是这么回事儿，酒给了10。1

老花就给了老酒10.

至此交易完成。

当然我们来实际看一下。

Alice想给Dave发送0.05 BTC，但Alice和Dave之间并没有微支付通道。但这没关系，Alice找到了一条经过Bob、Carol到达Dave的支付路径，该路径由Alice/Bob, Bob/Carol和Carol/Dave这样三个微支付通道串接而成。

Dave生成一个秘密R并将Hash(R)发送给Alice，Alice不需要知道R。R和Hash(R)的作用就像是古代调兵用的一对虎符。

Alice和Bob商定一个HTLC合约：只要Bob能在3天内向Alice出示哈希正确的R，Alice会支付Bob 0.052 BTC；如果Bob做不到这点，这笔钱3天后自动退还Alice。

同样地，Bob和Carol商定一个HTLC合约：只要Carol能在2天内向Bob出示哈希正确的R，Bob会支付Carol 0.051 BTC；如果Carol做不到这点，这笔钱到期自动退还Bob。

最后，Carol和Dave商定一个HTLC合约：只要Dave能在1天内向Carol出示哈希正确的R，Carol会支付Dave 0.05 BTC；如果Dave做不到这点，这笔钱到期自动退还Carol。

一切就绪后，Dave及时向Carol披露R并拿到0.05 BTC；现在Carol知道了R，她可以向Bob出示密码R并拿到0.051 BTC（差额部分的0.001 BTC成了Carol的佣金）；Bob知道R后当然会向Alice出示并拿到他的那份0.052 BTC，差额部分的0.001 BTC成了Bob的佣金。

另外以太坊基于闪电网络完成它们的支付通道雷电网络。









原子跨链交易
这里 我们假设。Alice 拥有1个比特币，Bob拥有10个比特币，他们都打算互相交易。

那么首先，我们来看第一步操作。

首先Alice ，生成一个只有自己知道的随机数X，并且生成一个 交易1，在这里面 输入的是 1个比特币，输出的是一段脚本，就是这样的一段脚本，我们查看这个脚本可以发现。

有两个条件满足该脚本运行。要么，拥有 随机值X的Hash符合条件并且拥有Bob的签名。要么 拥有 Alice 的签名和Bob的签名。

那么我们创建一个含有随机数值的交易，在这里我们可以看到，输入包含了一个随机数Hash以及Bob的签名。输出为 Bob立马得到1个bitCoin。

紧接着我们，创建一个赎回交易 Tx2，保证出现任何情况，Alice可以赎回自己的BitCoin.

在这里面，目前只包含了Alice的签名，以及一个输出，在输出里面，我们规定这个交易必须在48小时，之后才可以进块。也就是说该赎回交易会被锁定48小时。

之后我们将这个交易2 交给 Bob让他签名。签名完整之后，退回给Alice，这个时候，我们的交易2就是一个完整的交易了。

Alice把交易1发布出去。

这里Alice无需担心，Bob会取得这一个BitCoin ，在我们的设计中，取回这个交易的两个方式，Bob都不满足，首先他不知道X的值。其次他也不知道Alice的私钥，自然无法签名。所以这笔交易时安全的。及时出现Bob中途不打算交换也可以在48个小时后，赎回这一个比特币。


接下来，Bob也完成同样的操作。创建 交易3，书写脚本或者叫做智能合约。这里用脚本来表示。脚本中使用和 交易1 中一样的验证方式，也就是随机数hash确认，这个随机数就是Alice生成的随机数。

他会生成一个同样验证方式的随机数hash交易。

另外Bob也创建一个赎回交易4，该交易的Locktime为24个小时。可以保证，在Alice想要耍赖赎回交易1 24小时之前，Bob可以做出赎回操作。

之后，交给Alice签名。在签名之后，Alice 退回给 Bob。

这个时候，Bob将交易3发不出去。这个时候Let币会被锁定24个小时，在这24个小时之间

Alice可以通过自己创建的随机数X，去获取10个莱特币。

在Alice获取到莱特币的同时，Bob就知道了X的值，就可以使用同样的X值，去获取比特币。

当双方都确认完成之后，跨链交易完成，这就是原子交换。
