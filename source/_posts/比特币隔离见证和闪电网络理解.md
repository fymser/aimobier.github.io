---
categories: 区块链
title: 隔离见证 闪电网络 理解
tags:
  - Segwit
  - Lightning Network
  - Atomic Transaction
date: 2018-04-16 17:25:00
---

![](/publicFiles/images/隔离见证闪电网络/ShanwangpingKarst_EN-AU5360258756_1920x1080.jpg "要是可以回到5年前。一定要买比特币。")

bitcoin也许是有这样那样的问题，但是它是划时代的，面向未来的一次实验。        如今反对bitcoin的人的观点都是使用现今经济模式理论的，但他们有严重的逻辑缺陷——显然bitcoin是用来破坏这一模式的。        比如很多人阐述的bitecoin没有政府信用担保。事实上政府的存在也是依靠大众的信用。政府的信用只不过是大众赋予的。bitcoin本身就是大众（目前来说还是少数人）对政府控制铸币权的挑战。

<!-- more -->

接下来我们会从以下这几个方面完成一些讨论。

## 隔离见证

>Segregated Witness, or SegWit, is the name used for an implemented soft fork change in the transaction format of the cryptocurrency bitcoin, which has also been implemented on currencies such as Litecoin, DigiByte, Vertcoin and Feathercoin

在[SegWit Wikipedia](https://en.wikipedia.org/wiki/SegWit)中，我们可以看到，主要是为了防止延展性。所以接下来我们先来看看，如果没有隔离见证会发生什么样的问题呢？

### 为什么需要隔离见证

久负盛名的比特币交易所 MT.Gox 莫名其妙就破产了，MT.Gox 在比特币的发展史上作用巨大，一直作为比特币价格的风向标。直到上周它宣布破产，先前的“谣言”得到证实，人们才敢相信 MT.Gox 真的是倒闭了。

MT.Gox 在 2010 年就开始了比特币交易，比特币象征着自由、民主，具备改变世界金融秩序的潜力，MT.Gox 作为交易所也因此印上了离经叛道的光环。MT.Gox 尽管对比特币的发展贡献巨大，但作为一个交易所，一个商业机构，本身却做得一团糟，尤其是内部管理混乱、缺乏经验。

这种混乱的结果是，MT.Gox 逐渐积重难返，最后被黑客轻易得手，偷走了 4.6 亿美元的资产，MT.Gox 就此终结。
连线记者讲述了这段离奇的故事，MT.Gox 最早是美国企业家 Jed McCaleb 在 2010 年 7 月创办，域名注册于 2007 年，并在 2010 年底转为比特币交换平台。McCaleb 想法很简单，当时一个比特币已经可兑换数美元，而且挖矿机正在源源不断地产出新的比特币，他想建立一个交易所连接买家和卖家。

很快，这个交易所花光了 McCaleb 所有的积蓄，他意识到自己玩不下去了，于是出售给另一位比特币爱好者，网名叫 Magicaltux。

Magicaltux 正是 Mark Karpeles 的网名，他在法国出生，出生后在以色列呆了很长时间，最后定居日本、结婚，成为一名父亲。Karpeles 的生活可谓用悠闲来形容，除了照顾孩子，闲时还喜欢发一些猫咪的视频。当然，他喜欢比特币，2011 年，他将 MT.Gox 收购。

Karpeles 将网站的后端软件重写，改进了用户体验，加上他在比特币社区的活跃，越来越多的人在这里交易比特币，最终它变成了最流行的交易平台，承担着全球 70% 的交易。

这次收购促成 MT.Gox 一跃成为市场的领头羊，事实证明，Karpeles 对于技术的精通在网站发展初期十分有效，但是在后期，Karpeles 在商业管理的不足逐渐凸现出来，但 MT.Gox 并未因此做出改变。

比特币价格的飞涨给参与进来的人巨大的回报，MT.Gox 处理的流水越来越多，通过手续费累积的比特币也越来越多，数量达到了 10 万级别，总价值数千万美元。Karpeles 的身价也水涨船高，他拥有 MT.Gox 88% 的股权，前任拥有者 McCaleb 拥有剩余的 12%。

比特币的交易是建立在信用基础上，作为一名比特币爱好者，Karpeles 很注重外界对他的评价，这种想法甚至高于 MT.Gox 在商业上的成功。根据内部员工透露，他总是跟人说起自己是门萨俱乐部的一员，拥有高于常人的 IQ，这名员工说道：

![](/publicFiles/images/隔离见证闪电网络/mt-gox-bitcoin.jpg "Mark Karpeles")

> “他喜欢被赞扬的感觉，喜欢被叫做比特币之王。”

Karpeles 花费 5000 个比特币建立比特币基金会，在其中出任董事会成员，这是一个非盈利性组织，这将给他在比特币世界里带来威望。

但这些光环却掩盖不了 MT.Gox 在业务上的问题，MT.Gox 就像是在等待灾难来临，却从不去解决问题。

问题主要还是出在产品上，MT.Gox 很长一段时间都不使用控制软件来制定专业的开发环境，这意味着两个同事在同一个文件夹下工作，很有可能覆盖掉对方的代码。他们甚至把许多不经测试的软件推送到用户手机上，要知道他们是做金融服务的，这样做很容易引发问题。

在 MT.Gox 里，只有一个人有权限修改网站的源代码，即 Karpeles，这意味着源代码出问题的时候，需要 Karpeles 亲手来解决，但 CEO 通常都很忙，许多问题会拖好几周。糟糕的是，据员工透露，源代码的问题很多，bug 不断。

这些问题引发大商业客户的不满，去年他们被 CoinLab 起诉，要求赔偿 7500 万美元，原因是这家客户提现的时间居然被延迟了数月之久。彼时，许多其他交易网站逐渐崛起，MT.Gox 的交易数量额已经从第一掉到了第三名。

Karpeles 不重视产品简直到了无以复加的地步，2011 年 6 月，MT.Gox 首次遭遇黑客攻击，比特币爱好者 Jesse Powell 从旧金山赶过来，与好友 Roger Ver 一起帮 MT.Gox 解决问题，他们还没来得及放下行李就去办公室工作。当时受此影响，MT.Gox 比特币的价格暴跌，从 30 美元跌至 0.01 美元，比特币市场遭遇重创。

Powell、Ver 和 Karpeles 工作了一整周来修复问题，回答用户的咨询等，但是直到周末，问题还没解决。Powell、Ver 准备周末接着干，但意外的是，Karpeles 却决定周末放假休息，让两个志愿者大跌眼镜，他们感到十分泄气。

Karpeles 并未真正重视这个问题，等到周一开工，他却花时间在整理信封，把问题丢在一边。

接触他的人认为，Karpeles 逐渐厌倦做 CEO 了，对于问题采用消极的态度，他更喜欢花时间修理服务器、安装一些小工具等。

MT.Gox 新的大楼在建的时候，他还迷恋上新的项目：比特币咖啡馆。游人可以在里面休息，喝咖啡，但是付账只能使用比特币，这是 Karpeles 破解收银机的成果，Karpeles 很以此得意。当时 MT.Gox 已经处在下坡路上，这些周边的事物花去了 Karpeles 太多的精力。

“咖啡馆可能是 Karpeles 每天与银行、客户打交道这些暗无天日的日子里，唯一可以让他轻松的地方。”Powell 说道。可惜的是，咖啡馆终究没能开业。

随着 2 月份到来，危机终于降临，黑客利用比特币“可锻性”，将 MT.Gox 中的比特币洗劫一空，MT.Gox 也“暂停”提现比特币。在沉默了多天之后，示威者开始出现在办公室外面，谣言四起，但纸包不住火…

> 以上文字 引自[MT.Gox 倒闭内幕：不负责任的领导者葬送一切](https://www.ifanr.com/405596)

### 什么是交易延展性

什么叫做 延展性，说是延展性，也可以理解为可塑性。举个例子来说《龙门镖局》中的白敬祺为了藏私房钱，将银锭打成了银夜壶，而银夜壶和银锭的价值是相当的，这就是金属“可锻性”的物理表现。
比特币的一个“交易”是一段指令，这段指令告诉整个网络：我作为一些比特币的拥有者，要把他们的所有权转移到目标地址。这样，谁拥有目标地址，我就把钱打给谁了。
这段指令本质上是一个hash字符串，就像这样：

````java
01000000017a06ea98cd40ba2e3288262b28638cec5337c1456aaf5eedc8e9e5a20f062bdf000000008b48304502202ef6483a2509394551eadf333afe2a749dbe77729a7b729ad79bf2f2246483b0022100ce8a3f1801e32e95aeceac4ab400713b783120930f436774d27ca85c27428bfa014104e0ba531dc5d2ad13e2178
````
然后，你对这个字符串提取一个所谓的哈希，可以理解为用摘要的方式获得一个比较短的字符串，像这样的：
````java
0735353e82b8496eb87fc910d8cf814384028d0a853926c6acfd7b01190ea0b4
````

将这一个字符串进行解码之后，我们格式化出以下这一段JSON。

````javascript
{
   "ver":1,
   "inputs":[
      {
         "sequence":4294967295,
         "witness":"",
         "prev_out":{
            "spent":true,
            "tx_index":52155217,
            "type":0,
            "addr":"1DAtxVrwDDofiSwBqqiz4fkfPv1dCvt2Lx",
            "value":5020000,
            "n":1554,
            "script":"76a91485809fdc9c4cfebe73793cf1c4ddb328806737fd88ac"},
          "script”:”483045022100efe12e2584bbd346bccfe67fd50a54191e4f45f……"
      }
   ],
   "weight":768,
   "block_height":290000,
   "relayed_by":"24.13.82.77",
   "out":[
      {
         "spent":true,
         "tx_index":52159814,
         "type":0,
         "addr":"1JKygTtQjrY1mzMHLGuSdTEgi4P75vnjbG",
         "value":5010000,
         "n":0,
         "script":"76a914be10f0a78f5ac63e8746f7f2e62a5663eed0578888ac"
      }
   ]
   // .... 更多
}
````

在结构体中 input 第一个结构中 script "483045022100efe12e2584bbd346bccfe67fd50a54191e4f45f……" 就是咱们的输入脚本，这种格式下很难去辨认，所以格式化输出可以得到以下的结果。

````javascript
// 输入 脚本结构
// 其中 asm 为 签名 一起 公钥
{
	"result": {
		"asm": "3045022100efe12e2584bbd346bccfe67fd50a54191e4f45f945e3853658284358d9c062ad02200121e00b6297c0874650d00b786971f5b4601e32b3f81afa9f9f8108e93c752201 038b29d4fbbd12619d45c84c83cb4330337ab1b1a3737250f29cec679d7551148a",
		"type": "nonstandard",
		"p2sh": "3C7mDUFw5MLBw37bbsAN79mKuHi7oyjKwb"
	},
	"error": null,
	"id": null
}
````

同理，我们可以得到输出的格式化结构

````javascript
{
	"result": {
		"asm": "OP_DUP OP_HASH160 be10f0a78f5ac63e8746f7f2e62a5663eed05788 OP_EQUALVERIFY OP_CHECKSIG",
		"reqSigs": 1,
		"type": "pubkeyhash",
		"addresses": [
			"1JKygTtQjrY1mzMHLGuSdTEgi4P75vnjbG"
		],
		"p2sh": "3PDv3dAkEp7B57ReMs64grHiaEwTr3YEmb"
	},
	"error": null,
	"id": null
}
````

我们已经得到脚本的结构了。接下来看看脚本到底是如何做到检验脚本的

#### 逆波兰表达式

> 逆波兰结构由弗里德里希·鲍尔（Friedrich L. Bauer）和艾兹格·迪科斯彻在1960年代早期提议用于表达式求值，以利用堆栈结构减少计算机内存访问。逆波兰记法和相应的算法由澳大利亚哲学家、计算机学家查尔斯·汉布林（Charles Hamblin）在1960年代中期扩充
--- 摘自 [维基百科](https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)

大概的意思，它是基于堆栈的，先进后出 FILO(First-In-Last-Out)。就比如说，正常来说，我们实现一个加法操作。本来应该是
````javascript
1 + 2 =
````
按照 逆波兰 表达式来看的话，就是。
````javascript
1 2 + =
````

首先 `1` `2` 进栈。接着 运行到`+`，这个时候 `1` `2` 出栈，计算结果并入栈。 之后运行到 `=` 将结果出栈。

#### 运行脚本

我们的bitCoin的脚本也是使用的这种堆栈式执行的方式。我们来运行以下看看如何。(关于脚本的解释，引自[BitCoin Wiki Script](https://en.bitcoin.it/wiki/Script))

1. 运行输入脚本
2. 输入的 签名进栈 ，公钥进栈
3. 运行输出脚本
4. 运行 OP_DUP 它的含义是 复制栈顶元素 -> 复制公钥
5. 运行 OP_HASH160 含义是 将栈顶元素做 先SHA-256，在做 RIPEMD-160 -> 得到 公钥的HASH值
6. 之后 运行到 一段Hash 值，我们把它压栈
7. 运行到 OP_EQUALVERIFY 含义是 将栈顶前两个元素出栈 并判断是否相等 如果相等 就继续 否则就跳出并返回false
8. 运行到 OP_CHECKSIG 含义是检验 私钥和签名是否为真 结果同上

#### OP_CHECKSIG 细节

<!-- Reverse Border Black Blockquotes -->
<blockquote handle="nohandle" class="blockquote blockquote-reverse g-brd-2 g-brd-black g-font-size-16 g-mb-30">
  <footer class="blockquote-footer text-right"> 摘自 [<廖雪峰的官方网站 - 深入理解比特币交易的脚本>](https://www.liaoxuefeng.com/article/001482718603696a6b6eb2bebc74211ab967146a952ae0c000)
    <cite title="Source Title">廖雪峰</cite>
  </footer>
</blockquote>
<!-- End Reverse Border Black Blockquotes -->

把当前Transaction的所有TxIn的scriptSig去掉（红色部分），并把当前TxIn的scriptSig替换为UTXO的script（蓝色部分），调整长度字段（绿色部分）：

![](/publicFiles/images/隔离见证闪电网络/l.jpg "签名检验部分")

最后加上小端序4字节的签名类型0x01（灰色部分），计算两次SHA256，我们得到：

````javascript
c2d48f45...2669
````
现在，使用ECDSA算法对签名进行验证：

````c++
boolean ecdsa_verify_signature(byte[] message, byte[] signature, byte[] pubkey)
````

> 我们讲完了，执行过程，我们来看一下，如何完成交易延展性攻击。比特币区块链上每笔交易记录里都包含有见证信息，交易的唯一标识（交易的哈希值）也是包括了见证信息计算出来的。由于见证算法的数学特性，任何人在拿到一个交易记录后，拿到其中的见证信息，然后可以在不需要知道私钥的情况下，很容易的拼凑出另外一个有效的见证信息。这样，他可以用拼凑出来的另外那个见证信息，拼凑上交易记录中的其他交易信息，制造出一个另外一个交易记录（哈希值不同）。如果可以让拼凑出来的交易记录先被写入区块链，那么，之前那个原始交易记录会被认为是无效的交易而失败。这不会造成双花，也不会对区块链造成破坏，但是对原始交易记录的发起者会造成困扰，因为如果拿着原始交易记录的哈希值找不到交易的成功记录。尤其是对于一些交易所，如果没有完整的内部日志，可能无法追溯交易记录，导致攻击者利用拼凑的交易记录先成功提币，再申诉说没有提到币，要求再次提币。隔离见证后，见证信息不再是交易记录的一部分，也就不参与交易记录哈希的计算，无法再通过修改见证信息来拼凑另外一个交易记录。

> 作者：blockchain
链接：https://www.zhihu.com/question/58567061/answer/301418337
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


#### MT.Gox 攻击模拟

当交易发送到比特币网络中后，网络中的各个结点会根据之前生成的签名来验证交易的真实性，这些做法都是很正确很理所当然的，MT就是这么做的，当你提现的时候，它就发出一个交易，然后记录下这个ID。当有人提现出问题要求重发时，他们就用这个ID去比特币网络检查这个ID有没有被确认，如果没有的话就重发。而问题就出现在签名算法中，由于现在大部分使用的签名算法都是基于OpenSSL的ECDSA（椭圆曲线数字签名），这个签名算法的一个问题就是，修改签名的某个字节能够使得签名依然校验成功，这样伪造签名之后交易依然能成功进行。如果单在比特币网络中这似乎没什么大不了的，顶多可以捣捣乱，因为你能使用的输出就那一个，你其中一笔交易使用了输出，第二笔自然就不会成功。但是对于第三方交易系统就不同了


1. 你像交易所发起交易请求，交易所向比特币网络广播交易
2. 你通过矿机获取到交易，利用交易延展性，修改Txid
3. 假如你的交易率先完成了写入区块，攻击完成，你首先得到自己伪造交易的比特币
4. 你想交易所，申请，自己没有提到钱，申请在此提取
5. 交易所再次发起交易 你会得到两份比特币

大家还会有一个疑问，就是我们伪造的交易请求是在正常交易请求之后发出的，如果正常交易被采纳了，那我们伪造的交易如何能够奏效呢？这里就要说到比特币网络的一个特性，发出一个比特币交易请求后不会立刻返回交易成功与否，在比特币网络中会有一个处理延时，而比特币网络由于自身的特性，所有交易请求是以网状形式随机处理的，两次交易请求并不会以队列形式依次处理。这就给攻击者提供了可乘之机，专业的讲叫做时间条件竞争，通俗的讲就是拼人品。我们伪造的交易和正常的交易都在比特币网络中，如果伪造的交易先被处理，那么攻击成功。


## 闪电网络

**Transactions for the Future**

**Instant Payments**. Lightning-fast blockchain payments without worrying about block confirmation times. Security is enforced by blockchain smart-contracts without creating a on-blockchain transaction for individual payments. Payment speed measured in milliseconds to seconds.

**Scalability**. Capable of millions to billions of transactions per second across the network. Capacity blows away legacy payment rails by many orders of magnitude. Attaching payment per action/click is now possible without custodians.

**Low Cost**. By transacting and settling off-blockchain, the Lightning Network allows for exceptionally low fees, which allows for emerging use cases such as instant micropayments.

**Cross Blockchains**. Cross-chain atomic swaps can occur off-chain instantly with heterogeneous blockchain consensus rules. So long as the chains can support the same cryptographic hash function, it is possible to make transactions across blockchains without trust in 3rd party custodians.

> 引自 [Lightning Network 首页](https://lightning.network/)

### 为什么需要闪电网络

首先我们来说一下，现在比特币网络中存在的问题
1. 处理能力
  在最理想状态下，平均每笔交易225 字节。在1M区块限制下，一般平均10分钟可以打包大约 4400 笔交易。每秒大约7.3笔交易，实际交易平均大小是这个的一倍，那么容量减半，也就是每秒大约 3.6 笔交易。
  与当今的金融系统相比，Visa在标准的节假日每秒处理4.5万笔交易，通常的一个营业日则为数亿次交易。支付宝的每秒可以处理10万笔交易。而2017年的双11，支付峰值每秒25.6万笔。，然而比特币现在每秒约能支持7笔交易，同时还会受到区块链大小的限制。
2. 时间延迟
  每一笔交易发起的时候，会出现10分钟的延迟，才会有可能被矿工确认。并且目前的交易量上升之后，你被确认的等待时间和你的手续费成反比，也就是说你的手续费越低，你被处理的顺序就越靠后。
3. 交易最终性
  由于算哈希是随机的，加上网络有延迟，是有同时挖出两个区块的可能，然后不同的矿工根据他们收到的区块不同继续挖，然后还是有可能再出现分叉，但是几率会越来越小。
  一般认为一个区块在最长链上后面跟了五个区块，就不可能被分叉了。随着区块数量的增加，再次产生分叉的几率是呈指数下降的。到了6的区块的时候，就已经下降到不太可能分叉的情况
4. 容量
  比特币，区块目前已经到51W多个区块。这么多的区块产生的容量是巨大的,而且以后只增不减
5. 交易费
  中本聪最开始确定bitcoin一共有2100万个，当全部挖掘出来之后，矿工将不再获得奖励，到那个时候，矿工所有的收益都来自交易中的手续费。就目前为止，待确认交易堆积的这么多，也和交易费有关系，如果你想矿工早点确认你的交易，那么你就需要提高你的手续费，否则就没人处理。但是这个引起的来问题，也很明显，我就想买杯咖啡，就需要支付手续费吗？


闪电网络就是为了这解决这些的。

#### 闪电网络 - RSMC

闪电网络的基础是交易双方之间的双向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定义了该双向微支付通道的最基本工作方式。

微支付通道中沉淀了一部分资金，通道也记录有双方对资金的分配方案。通道刚设立时，初值可能是{Alice: 0.4, Bob: 0.6}，意味着打入通道的资金共有1.0 BTC，其中Alice拥有0.4 BTC，Bob拥有0.6 BTC。通道的设立会记录在比特币区块链上。

假设稍后Bob决定向Alice支付0.1 BTC。双方在链下对最新余额分配方案{Alice:0.5, Bob:0.5} 签字认可，并签字同意作废前一版本的余额分配方案{Alice:0.4, Bob:0.6}，Alice就实际获得了0.5 BTC的控制权。

![](/publicFiles/images/隔离见证闪电网络/Snip20160612_90.png "前后两个版本的余额分配方案")

如果Alice暂时不需要将通道中现在属于她的0.5 BTC用作支付，她可以无需及时更新区块链上记录的通道余额分配方案，因为很可能一分钟后Alice又需要反过来向Bob支付0.1 BTC，此时他们仍然只需在链下对新的余额分配方案达成一致，并设法作废前一版本的余额分配方案就行了。

如果Alice打算终止通道并动用她的那份资金，她可以向区块链出示双方签字的余额分配方案。如果一段时间之内Bob不提出异议，区块链会终止通道并将资金按协议转入各自预先设立的提现地址。如果Bob能在这段时间内提交证据证明Alice企图使用的是一个双方已同意作废的余额分配方案，则Alice的资金将被罚没并给到Bob。

实际上，前面所说的“作废前一版本的余额分配”，正是通过构建适当的“举证”证据并结合罚没机制实现的。

为了鼓励双方尽可能久地利用通道进行交易，RSMC对主动终止通道方给予了一定的惩罚：主动提出方其资金到账将比对方晚，因此谁发起谁吃亏。这个设计虽然增加了技术复杂度，但应该说是合理的。

通道余额分配方案的本质是结算准备金。在此安排下，因为要完全控制资金交收风险，每笔交易都不能突破当前结算准备金所施限制。

#### 闪电网络 - HTLC

RSMC只支持最简单的无条件资金支付，HTLC（Hashed Timelock Contract）进一步实现了有条件的资金支付，通道余额的分配方式也因此变得更为复杂。

通过HTLC，Alice和Bob可以达成这样一个协议：协议将锁定Alice的0.1 BTC，在时刻T到来之前（T以未来的某个区块链高度表述），如果Bob能够向Alice出示一个适当的R（称为秘密），使得R的哈希值等于事先约定的值H(R)，Bob就能获得这0.1 BTC；如果直到时刻T过去Bob仍然未能提供一个正确的R，这0.1 BTC将自动解冻并归还Alice。

由于到期时间T、提款条件H(R)、支付金额、支付方向的不同，同一个通道上可以同时存在多个活动的HTLC合约，加上唯一的通过RSMC协议商定的无条件资金余额，余额分配方式会变得相当复杂。假设双方初始各存入0.5 BTC，一段时间后余额分配可能这样：


![](/publicFiles/images/隔离见证闪电网络/Snip20160612_91.png "一段时间后的余额分配方案")

余额分配方案是一种快照，只能整体刷新。接上表，如果Alice下一刻决定无条件向Bob支付0.1 BTC，或者Alice在T1前向Bob出示了符合H(R1)的秘密，双方将在链下交换并共同签字认定新的快照，然后构建适当的“举证”证据，结合罚没机制作废前一版本的快照。这些动作完全不出现在区块链上。
引入HTLC后，任何一方仍然能通过在区块链上公开最终余额快照的方式终止通道。

#### 闪电网络

基于HTLC可以实现终极目标“闪电网络”。

![](/publicFiles/images/隔离见证闪电网络/Snip20160612_92.png "闪电网络的支付路径")

如上图所示，Alice想给Dave发送0.05 BTC，但Alice和Dave之间并没有微支付通道。但这没关系，Alice找到了一条经过Bob、Carol到达Dave的支付路径，该路径由Alice/Bob, Bob/Carol和Carol/Dave这样三个微支付通道串接而成。

Dave生成一个秘密R并将Hash(R)发送给Alice，Alice不需要知道R。R和Hash(R)的作用就像是古代调兵用的一对虎符。

Alice和Bob商定一个HTLC合约：只要Bob能在3天内向Alice出示哈希正确的R，Alice会支付Bob 0.052 BTC；如果Bob做不到这点，这笔钱3天后自动退还Alice。

同样地，Bob和Carol商定一个HTLC合约：只要Carol能在2天内向Bob出示哈希正确的R，Bob会支付Carol 0.051 BTC；如果Carol做不到这点，这笔钱到期自动退还Bob。

最后，Carol和Dave商定一个HTLC合约：只要Dave能在1天内向Carol出示哈希正确的R，Carol会支付Dave 0.05 BTC；如果Dave做不到这点，这笔钱到期自动退还Carol。

一切就绪后，Dave及时向Carol披露R并拿到0.05 BTC；现在Carol知道了R，她可以向Bob出示密码R并拿到0.051 BTC（差额部分的0.001 BTC成了Carol的佣金）；Bob知道R后当然会向Alice出示并拿到他的那份0.052 BTC，差额部分的0.001 BTC成了Bob的佣金。

![](/publicFiles/images/隔离见证闪电网络/Snip20160612_93.png "闪电网络逐级提款")

整个过程很容易理解。最终效果是Alice支付了0.052 BTC，Dave安全地拿到0.05 BTC，整个闪电支付网络为此收取的佣金成本是0.002 BTC。上述过程中的全部动作都发生在比特币区块链之外。

尽管闪电网络本身可以基于任何合适的传统技术构建，闪电网络的支付通道也可能逐渐向少数大型中介集中，变成若干大型中介彼此互联、普通用户直连大型中介的形式，但这种方案仍然具有传统中心化方案不可比拟的优势，因为用户现在并不需要信任中介，不需要在中介处存钱才能转移支付，资金安全受到比特币区块链的充分保护。

比特币闪电网络的实现方式非常复杂，不拟在此展开讲解，有兴趣的读者可以在附录一中找到详细的技术剖析。



<!-- Reverse Border Black Blockquotes -->
<blockquote handle="nohandle" class="blockquote blockquote-reverse g-brd-2 g-brd-black g-font-size-16 g-mb-30">
  <footer class="blockquote-footer text-right"> 闪电网络学习自 [详解最近大热的闪电网络、雷电网络和CORDA](http://www.8btc.com/ln-rn-corda)
    <cite title="Source Title">上交所朱立</cite>
  </footer>
</blockquote>
<!-- End Reverse Border Black Blockquotes -->


#### 吐槽百度

真的不得不吐槽下百度哈..... 都是搜索文章标题，为什么差距有些大

![](/publicFiles/images/隔离见证闪电网络/WX20180417-110420.png "百度搜索结果")
![](/publicFiles/images/隔离见证闪电网络/WX20180417-110442.png "Google搜索结果")

## 原子交易

A picks a random number x

A creates TX1: "Pay w BTC to <B's public key> if (x for H(x) known and signed by B) or (signed by A & B)"

A creates TX2: "Pay w BTC from TX1 to <A's public key>, locked 48 hours in the future, signed by A"

A sends TX2 to B

B signs TX2 and returns to A

1) A submits TX1 to the network

B creates TX3: "Pay v alt-coins to <A-public-key> if (x for H(x) known and signed by A) or (signed by A & B)"

B creates TX4: "Pay v alt-coins from TX3 to <B's public key>, locked 24 hours in the future, signed by B"

B sends TX4 to A

A signs TX4 and sends back to B

2) B submits TX3 to the network

3) A spends TX3, revealing x

4) B spends TX1 using x

This is atomic (with timeout).  If the process is halted, it can be reversed no matter when it is stopped.

Before 1: Nothing public has been broadcast, so nothing happens
Between 1 & 2: A can use refund transaction after 72 hours to get his money back
Between 2 & 3: B can get refund after 24 hours.  A has 24 more hours to get his refund
After 3: Transaction is completed by 2
- A must spend his new coin within 24 hours or B can claim the refund and keep his coins
- B must spend his new coin within 72 hours or A can claim the refund and keep his coins

For safety, both should complete the process with lots of time until the deadlines.

## 原子交易 闪电网络

<blockquote handle="nohandle" class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr">Special thanks to <a href="https://twitter.com/bitconner?ref_src=twsrc%5Etfw">@bitconner</a> for his super hard work on this! 🙌<br><br>And <a href="https://twitter.com/roasbeef?ref_src=twsrc%5Etfw">@roasbeef</a> and <a href="https://twitter.com/SatoshiLite?ref_src=twsrc%5Etfw">@SatoshiLite</a> for the help and feedback!</p>&mdash; Lightning Labs⚡️ (@lightning) <a href="https://twitter.com/lightning/status/931277482359005184?ref_src=twsrc%5Etfw">2017年11月16日</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


## 动画演示

更多详解 可以查看 [Pages](http://7xt8nx.com1.z0.glb.clouddn.com/%E6%95%B0%E5%AD%97%E9%92%B1%E5%8C%85%E8%B0%83%E7%A0%94%20%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC.key) 以及 它的[描述文件](/publicFiles/images/隔离见证闪电网络/PPT 文稿.md)
